<link rel="import" href="bower_components/paper-button/paper-button.html">

<link rel="import" href="bower_components/polymerfire/polymerfire.html">

<!-- jQuery and Blockrain.js -->
<script src="bower_components/jquery/dist/jquery.min.js"></script>

<dom-module id="playground-splash">

  <template>

    <style>

    :host {
      z-index: -1;
      position: absolute;
      padding:0px;
      left:0px;
      top: 0px;
      height: 100%;
      width: 100%;
    }

    .copy-container {
      height: 100%;
      width: 100%;
      display: table;
      position: absolute;
    }

    .copy {
      text-align: center;
      display: table-cell;
      vertical-align: middle;
      position: relative;
    }

    .supertitle {
      font-size: 2rem;
      font-weight: 700;
      line-height: 1.1;
      margin: 0.67em 0;
      color: #333
    }

    .title {
      font-size: 6rem;
      font-weight: 700;
      line-height: 1.1;
      margin: 0.67em 0;
      color: #333
    }

    .subtitle-container {
      padding: 30px;
    }

    .subtitle {
      color: #333;
      font-weight: 500;
      font-size: 1.4rem;
      line-height: 1.1;

    }

    .cta-button {
      background-color: #0168FA;
      border: none;
      color: #FFFFFF;
      padding: 6.25px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 11px;
      text-transform: uppercase;
      margin: 0px 0px 0px 0px;
      line-height: 1.773;
      font-weight:700;
    }

    .paused-buttons {
        font-size: 11px;
    }

    .cta-button[disabled] {
      border: 2px solid lightgrey;
    }

    .blockrain-game-over-holder {
      visibility: hidden;
    }

    @media (max-width: 640px) {
      .supertitle {
        font-size: 1rem;
      }
      .title {
        font-size: 2.8rem;
      }
      .subtitle {
        font-size: 1rem;
      }
      .cta-button {
        padding: 5px 16px;
        margin: 10px;
      }
    }

    a {
      text-decoration: none;
      color: #333;
    }

    .score {
      visibility: hidden;
      position: absolute;
      bottom: 0px;
      left: 0px;
      text-align: left;
      width: 100px;
      padding: 40px;
    }

    .demo-controls {
      visibility: hidden;
      position: absolute;
      bottom: 0px;
      right: 0px;
      text-align: right;
      width: 100px;
      padding: 40px;
    }

    .cta-secondary {
      background-color: white;
      border: 1px solid #c0ccda;
      color: rgba(27, 46, 75, 0.7);
      padding: 6.25px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 11px;
      text-transform: uppercase;
      margin: 0px 0px 0px 0px;
      line-height: 1.773;
      font-weight:700;
    }

    .demo-canvas {
      z-index: -1;
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0px;
      left: 0px;
      visibility: hidden;
    }

    </style>

    <div class="score">Distance from goal: [[score]]</div>

    <div class="demo-controls">

      <paper-button on-tap="init" class="cta-secondary">Update</paper-button>
      <paper-button on-tap="pause" class="cta-secondary">Pause</paper-button>

    </div>

    <svg class="demo-canvas" id="svg"></svg>

    <div class="copy-container">

      <div class="copy">

        <h2 class="supertitle">Project Clarify</h2>

        <div class="subtitle-container">
          <p class="subtitle">"Perspective Shift" demonstration.
          </p>

        </div>

        <div class="paused-buttons">

          <paper-button on-tap="play" hidden$="[[signedIn]]" class="cta-button">Run demo</paper-button>

          <p hidden$="[[!signedIn]]">Please sign in to continue... ðŸŽ‰</p>

        </div>

      </div>

    </div>

  </template>


  <script>

      /*

      - possibly don't use polymer if it interferes with the way d3 expects to access dom elements
      - keeping it simple first 
        - display of controls
        - scatterplot can be rotated in 3d using the mouse or finger
        - scatter display a function of display size
        - scatter data is obtained from firebase including positions of special elements (e.g. a goal)
        - scatterplot can be made to slowly rotate
        - scale to fill more of the screen
        - points of reference that aren't distracting like lightly colored axes
      - *possibly* the ability to toggle display of various streams of data.

      - it could definitely do nearest neighbor lookup to show you examples of other people expressing emotions
        similar to yours at this moment. or lookup of emotions of yours similar to your current ones.

      - selecting what label to color by even though layout isn't computed strictly from labels.

      */

    Polymer({

      is: 'playground-splash',

      properties: {
        signedIn: {
          type: Boolean,
          reflectToAttribute: true,
          value: false
        },
        score: {
          type: Number,
          value: 0,
        },
        paused: {
          type: Boolean,
          value: false,
        },
      },

      pause: function() {
        Polymer.dom(this.root).querySelector('.copy-container').style.visibility = "visible";
        Polymer.dom(this.root).querySelector('.demo-controls').style.visibility = "hidden";
        Polymer.dom(this.root).querySelector('.score').style.visibility = "hidden";
        Polymer.dom(this.root).querySelector('.demo-canvas').style.visibility = "hidden";
        this.paused = true;
      },

      play: function() {
        Polymer.dom(this.root).querySelector('.copy-container').style.visibility = "hidden";
        Polymer.dom(this.root).querySelector('.demo-controls').style.visibility = "visible";
        Polymer.dom(this.root).querySelector('.score').style.visibility = "visible";
        Polymer.dom(this.root).querySelector('.demo-canvas').style.visibility = "visible";
        this.paused = false;
      },

      // ---
      // Begin Polymer port from @niekes d3-3d demo
      // https://bl.ocks.org/niekes/1c15016ae5b5f11508f92852057136b5

      ready: function() {
        this.createElements();
        this.init();
        //console.log(this.grid3d);
        //console.log(this.svg);
        //console.log("test");
      },

      createElements: function () {

        var scale = 20;

        var origin = [480, 300];

        this.scatter = [];
        this.yLine = [];
        this.xGrid = [];
        this.beta = 0;
        this.alpha = 0;
        this.startAngle = Math.PI/4;

        var width = 1000,
            height = 1000,
            radius = Math.min(width, height) / 2;

        //this.svg = d3.select(this.$.svg)
        //    .attr("width", width)
        //    .attr("height", height)
        //.append("g")
        //    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        this.svg    = d3.select(this.$.svg).append('g');
        //.call(d3.drag().on('drag', this.dragged).on('start', this.dragStart).on('end', this.dragEnd)).append('g');

        //this.svg = d3.select(this.$.svg).append('g');

        var mx, my, mouseX, mouseY;

        this.grid3d = d3._3d()
            .shape('GRID', 20)
            .origin(origin)
            .rotateY( this.startAngle)
            .rotateX(-this.startAngle)
            .scale(scale);

        this.point3d = d3._3d()
            .x(function(d){ return d.x; })
            .y(function(d){ return d.y; })
            .z(function(d){ return d.z; })
            .origin(origin)
            .rotateY( this.startAngle)
            .rotateX(-this.startAngle)
            .scale(scale);

        this.yScale3d = d3._3d()
            .shape('LINE_STRIP')
            .origin(origin)
            .rotateY( this.startAngle)
            .rotateX(-this.startAngle)
            .scale(scale);

      },

      processData: function(data, tt){

        key = function(d){ return d.id; };

        /* ----------- GRID ----------- */

        var xGrid = this.svg.selectAll('path.grid').data(data[0], key);

        //console.log(data[0]);

        xGrid
            .enter()
            .append('path')
            .attr('class', '_3d grid')
            .merge(xGrid)
            .attr('stroke', 'black')
            .attr('stroke-width', 0.3)
            .attr('stroke-opacity', 0)
            .attr('fill', function(d){ return d.ccw ? 'lightgrey' : '#717171'; })
            .attr('fill-opacity', 0)
            .attr('d', this.grid3d.draw);

        xGrid.exit().remove();

        /* ----------- POINTS ----------- */

        color  = d3.scaleOrdinal(d3.schemeCategory20);

        var points = this.svg.selectAll('circle').data(data[1], key);

        points
            .enter()
            .append('circle')
            .attr('class', '_3d')
            .attr('opacity', 0)
            .attr('cx', this.posPointX)
            .attr('cy', this.posPointY)
            .merge(points)
            .transition().duration(tt)
            .attr('r', 3)
            .attr('stroke', function(d){ return d3.color(color(d.id)).darker(3); })
            .attr('fill', function(d){ return color(d.id); })
            .attr('opacity', 1)
            .attr('cx', this.posPointX)
            .attr('cy', this.posPointY);

        points.exit().remove();

        /* ----------- y-Scale ----------- */

        var yScale = this.svg.selectAll('path.yScale').data(data[2]);

        yScale
            .enter()
            .append('path')
            .attr('class', '_3d yScale')
            .merge(yScale)
            .attr('stroke', 'black')
            .attr('stroke-width', .5)
            .attr('d', this.yScale3d.draw);

        yScale.exit().remove();
        

         /* ----------- y-Scale Text ----------- */

        /*
        var yText = this.svg.selectAll('text.yText').data(data[2][0]);

        yText
            .enter()
            .append('text')
            .attr('class', '_3d yText')
            .attr('dx', '.3em')
            .merge(yText)
            .each(function(d){
                d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
            })
            .attr('x', function(d){ return d.projected.x; })
            .attr('y', function(d){ return d.projected.y; })
            .text(function(d){ return d[1] <= 0 ? d[1] : ''; });

        yText.exit().remove();
        */

        d3.selectAll('._3d').sort(d3._3d().sort);
    },

    posPointX: function(d){
        return d.projected.x;
    },

    posPointY: function(d){
        return d.projected.y;
    },

	init: function(){
        var cnt = 0;
        var j = 20;
        var xGrid = []
        var scatter = []
        var yLine = [];
        for(var z = 0; z < j; z++){
            for(var x = 0; x < j; x++){
                xGrid.push([x, 1, z]);
                scatter.push({x: x, y: d3.randomUniform(0,j)(), z: z, id: 'point_' + cnt++});
            }
        }

        d3.range(-1, 11, 1).forEach(function(d){ yLine.push([-j, -d, -j]); });

        var data = [
            this.grid3d(xGrid),
            this.point3d(scatter),
            this.yScale3d([yLine])
        ];

        this.processData(data, 5000);
    },

    dragStart: function(){
        mx = d3.event.x;
        my = d3.event.y;
    },

    dragged: function(){

        var startAngle = this.startAngle;

        mouseX = mouseX || 0;
        mouseY = mouseY || 0;
        beta   = (d3.event.x - mx + mouseX) * Math.PI / 230 ;
        alpha  = (d3.event.y - my + mouseY) * Math.PI / 230  * (-1);
        var data = [
          this.grid3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(xGrid),
          this.point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(this.scatter),
          this.yScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([yLine]),
        ];
        this.processData(data, 0);
    },

    dragEnd: function(){
        mouseX = d3.event.x - mx + mouseX;
        mouseY = d3.event.y - my + mouseY;
    },
    
    });

  </script>

</dom-module>
